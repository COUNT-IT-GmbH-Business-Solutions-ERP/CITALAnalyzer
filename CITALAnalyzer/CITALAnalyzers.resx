<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AnalyzerPrefix" xml:space="preserve">
  <!-- Prefix -->
    <value>CI</value>
  </data>
    <data name="Rule0001CheckForPrefixInVariableNameDescription" xml:space="preserve">
    <value>Name of Variables must not contain a prefex except it is necessary for avoiding conflicts.</value>
  </data>
  <data name="Rule0001CheckForPrefixInVariableNameFormat" xml:space="preserve">
    <value>Name of Variables must not contain a prefex except it is necessary for avoiding conflicts.</value>
  </data>
  <data name="Rule0001CheckForPrefixInVariableNameTitle" xml:space="preserve">
    <value>Name of Variables must not contain a prefex except it is necessary for avoiding conflicts.</value>
  </data>
  <data name="Rule0002CheckForMissingCaptionsDescription" xml:space="preserve">
    <value>Caption is missing.</value>
  </data>
  <data name="Rule0002CheckForMissingCaptionsFormat" xml:space="preserve">
    <value>Caption is missing.</value>
  </data>
  <data name="Rule0002CheckForMissingCaptionsTitle" xml:space="preserve">
    <value>Caption is missing.</value>
  </data>
  <data name="Rule0003CheckIfDefaultDataClassificationDescription" xml:space="preserve">
    <value>Data Classification is equal to the default value. Remove to reduce redundancy.</value>
  </data>
  <data name="Rule0003CheckIfDefaultDataClassificationFormat" xml:space="preserve">
    <value>Data Classification is equal to the default value. Remove to reduce redundancy.</value>
  </data>
  <data name="Rule0003CheckIfDefaultDataClassificationTitle" xml:space="preserve">
    <value>Data Classification is equal to the default value. Remove to reduce redundancy.</value>
  </data>
  <data name="Rule0004NameOfEventSubscriberHasToMatchEventDescription" xml:space="preserve">
    <value>The name of the event subscriber must match the name of the event it subscribes to. In case of subscribing to a specific element, add the name of the element before the eventname and seperate them by using '_'.</value>
  </data>
  <data name="Rule0004NameOfEventSubscriberHasToMatchEventFormat" xml:space="preserve">
    <value>The name of the event subscriber must match the name of the event it subscribes to. In case of subscribing to a specific element, add the name of the element before the eventname and seperate them by using '_'.</value>
  </data>
  <data name="Rule0004NameOfEventSubscriberHasToMatchEventTitle" xml:space="preserve">
    <value>The name of the event subscriber must match the name of the event it subscribes to. In case of subscribing to a specific element, add the name of the element before the eventname and seperate them by using '_'.</value>
  </data>
  <data name="Rule0005CheckForUnnecessaryParamsInEventSubDescription" xml:space="preserve">
    <value>An event subscriber should only receive the parameters it actually needs.</value>
  </data>
  <data name="Rule0005CheckForUnnecessaryParamsInEventSubFormat" xml:space="preserve">
    <value>An event subscriber should only receive the parameters it actually needs.</value>
  </data>
  <data name="Rule0005CheckForUnnecessaryParamsInEventSubTitle" xml:space="preserve">
    <value>An event subscriber should only receive the parameters it actually needs.</value>
  </data>
  <data name="Rule0006EmptyCaptionLockedTitle" xml:space="preserve">
    <value>Empty captions should be locked.</value>
  </data>
  <data name="Rule0006EmptyCaptionLockedFormat" xml:space="preserve">
    <value>Empty captions should be locked.</value>
  </data>
  <data name="Rule0006EmptyCaptionLockedDescription" xml:space="preserve">
    <value>Empty captions should be locked.</value>
  </data>
  <data name="Rule0007VariablesNameContainsALObjectAndNoSpecialCharsTitle" xml:space="preserve">
    <value>Variables must contain the name of the AL object but no speical characters or whitespaces.</value>
  </data>
  <data name="Rule0007VariablesNameContainsALObjectAndNoSpecialCharsFormat" xml:space="preserve">
    <value>Variables must contain the name of the AL object but no speical characters or whitespaces.</value>
  </data>
  <data name="Rule0007VariablesNameContainsALObjectAndNoSpecialCharsDescription" xml:space="preserve">
    <value>Variables must contain the name of the AL object but no speical characters or whitespaces.</value>
  </data>
  <data name="Rule0008EventSubsInCorrectCodeunitTitle" xml:space="preserve">
    <value>EventSubscribers must always be placed in a Codeunit that has the same name as the object to which the event belongs.</value>
  </data>
  <data name="Rule0008EventSubsInCorrectCodeunitFormat" xml:space="preserve">
    <value>EventSubscribers must always be placed in a Codeunit that has the same name as the object to which the event belongs.</value>
  </data>
  <data name="Rule0008EventSubsInCorrectCodeunitDescription" xml:space="preserve">
    <value>EventSubscribers must always be placed in a Codeunit that has the same name as the object to which the event belongs.</value>
  </data>
  <data name="Rule0009CheckForAddMoveBeforeAfterinPageExtTitle" xml:space="preserve">
    <value>It is not allowed to use 'addbefore', 'addafter', 'movebefore' or 'moveafter' in Page Extensions.</value>
  </data>
  <data name="Rule0009CheckForAddMoveBeforeAfterinPageExtFormat" xml:space="preserve">
    <value>It is not allowed to use 'addbefore', 'addafter', 'movebefore' or 'moveafter' in Page Extensions.</value>
  </data>
  <data name="Rule0009CheckForAddMoveBeforeAfterinPageExtDescription" xml:space="preserve">
    <value>It is not allowed to use 'addbefore', 'addafter', 'movebefore' or 'moveafter' in Page Extensions.</value>
  </data>
  <data name="Rule0010CallByReferenceOnlyIfVariableChangedInProcedureTitle" xml:space="preserve">
    <value>Call by reference may only be used if the variable is modified within the procedure.</value>
  </data>
  <data name="Rule0010CallByReferenceOnlyIfVariableChangedInProcedureFormat" xml:space="preserve">
    <value>Call by reference may only be used if the variable is modified within the procedure.</value>
  </data>
  <data name="Rule0010CallByReferenceOnlyIfVariableChangedInProcedureDescription" xml:space="preserve">
    <value>Call by reference may only be used if the variable is modified within the procedure.</value>
  </data>
    <!--  #############################################################################################################   -->
  <data name="Rule0011AlwaysUseSetLoadFieldsWhenFetchingRecordsTitle" xml:space="preserve">
    <value>SetLoadFields must always be used before fetching a record from the database.</value>
  </data>
  <data name="Rule0011AlwaysUseSetLoadFieldsWhenFetchingRecordsFormat" xml:space="preserve">
    <value>SetLoadFields must always be used before fetching a record from the database.</value>
  </data>
  <data name="Rule0011AlwaysUseSetLoadFieldsWhenFetchingRecordsDescription" xml:space="preserve">
    <value>SetLoadFields must always be used before fetching a record from the database.</value>
  </data>
    <data name="Rule0012UseSetAutoCalcFieldsInsteadOfCalcFieldsTitle" xml:space="preserve">
    <value>Always use SetAutoCalcFields instead of CalcFields.</value>
  </data>
  <data name="Rule0012UseSetAutoCalcFieldsInsteadOfCalcFieldsFormat" xml:space="preserve">
    <value>Always use SetAutoCalcFields instead of CalcFields.</value>
  </data>
  <data name="Rule0012UseSetAutoCalcFieldsInsteadOfCalcFieldsDescription" xml:space="preserve">
    <value>Always use SetAutoCalcFields instead of CalcFields.</value>
  </data>
    <data name="Rule0013UseCalcSumWhenCalculationSumOfFieldInFilterTitle" xml:space="preserve">
    <value>When calculating the sum of a field in a filter, CalcSums must always be used.</value>
  </data>
  <data name="Rule0013UseCalcSumWhenCalculationSumOfFieldInFilterFormat" xml:space="preserve">
    <value>When calculating the sum of a field in a filter, CalcSums must always be used.</value>
  </data>
  <data name="Rule0013UseCalcSumWhenCalculationSumOfFieldInFilterDescription" xml:space="preserve">
    <value>When calculating the sum of a field in a filter, CalcSums must always be used.</value>
  </data>
    <data name="Rule0014IfTextIsContinuouslyChangedUseTextBuilderTitle" xml:space="preserve">
    <value>If a text is continuously changed, the data type TextBuilder must be used.</value>
  </data>
  <data name="Rule0014IfTextIsContinuouslyChangedUseTextBuilderFormat" xml:space="preserve">
    <value>If a text is continuously changed, the data type TextBuilder must be used.</value>
  </data>
  <data name="Rule0014IfTextIsContinuouslyChangedUseTextBuilderDescription" xml:space="preserve">
    <value>If a text is continuously changed, the data type TextBuilder must be used.</value>
  </data>
    <data name="Rule0015DefineProcedureAsSourceExpressionInPageFieldTitle" xml:space="preserve">
    <value>"Procedures should be specified directly as a Source Expression in a Page Field, not in OnAfterGetRecord().</value>
  </data>
  <data name="Rule0015DefineProcedureAsSourceExpressionInPageFieldDescription" xml:space="preserve">
    <value>"Procedures should be specified directly as a Source Expression in a Page Field, not in OnAfterGetRecord().</value>
  </data>
  <data name="Rule0015DefineProcedureAsSourceExpressionInPageFieldFormat" xml:space="preserve">
    <value>"Procedures should be specified directly as a Source Expression in a Page Field, not in OnAfterGetRecord().</value>
  </data>
</root>